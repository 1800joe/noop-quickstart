noop Quick Start Guide
======================

# What is noop?

noop is an application platform for you to build, run, and live with your apps. You write code and provide noop with a description of your application via a configuration file or files (called noopfiles), and noop takes care of the rest.

A noopfile is a configuration file that lives in your code's repository. It describes the structure of your application in terms of a collection of components (which you can think of as running code), resources (which you can think of as backend services like databases), and the relationships between them. Each version of your application will result in a deployment of a new version of each component when it is deployed, but the resources will stick around.

This guide will help you to get started using noop by deploying a sample application, so you can quickly gain a better understanding of how components, resources, and a noopfile all work together.

Let's get started!

# The sample application

The sample application is a simple web app to manage coffee samples that are handed out at a grocery store. The code and noopfiles for it live in this repository. It is comprised of:

1. A [DynamoDB](https://aws.amazon.com/dynamodb/) *resource* to store to-do list items
2. A function *component* to list the samples currently being served
3. A function *component* to add a new coffee sample to be served
4. A function *component* to stop serving a coffee sample
5. A service *component* that returns a web page that allows a user to view and manage the samples being handed out

A function *component* executes some code statelessly in a container. Every time a function component is called (like via a web request), a new container is created. After the function call is completed, the container is destroyed.

A service *component* also executes some code in a container. The difference between service and function components is that service containers are more long-lived. A single service container can handle multiple calls over the course of its lifetime. This is useful TODO.

*Resources* have an indefinite lifespan. They are created in noop through the noop console, or are automatically generated by the noop CLI locally. Databases are the most obvious example of a resource, but it also includes other long-lived things like queues, caches, object stores, etc.

## Getting Started

First, you'll need to fork this repository in GitHub.

Once you've forked the repo, you'll need to clone your fork to your local machine. If you haven't already, open up a terminal and enter:

```bash
git clone git@github.com:rearc/noop-quickstart.git
cd noop-quickstart
```

You'll notice that the sample app is organized into directories in the root of the repository:

```bash
noop-quickstart
├ list-samples
│  ├ Noopfile
│  ├ package.json
│  └ index.js
├ add-sample
│  ├ Noopfile
│  ├ package.json
│  └ index.js
├ remove-sample
│  ├ Noopfile
│  ├ package.json
│  └ index.js
└ ui
   ├ Noopfile
   ├ package.json
   └ index.js
```

Each directory corresponds to a component, and contains a `Noopfile` that describes the component. Note that noop does not impose any sort of requirements on the structure of your application. Let's look at the noopfile for the component in `list-samples`:

```
COMPONENT list-samples
ROUTE -m GET /api/samples
RESOURCE samples dynamodb
ENV SAMPLES_TABLE_NAME $.resources.samples.tableName
FROM rearc/noop-nodejs-function:v6.11
COPY package.json package.json
RUN npm install
COPY *.js /function/
FUNCTION ["/function/index.js", "handler"]
```

You may notice that the noopfile format looks very similar to a [Dockerfile](https://docs.docker.com/engine/reference/builder/). In fact, the noopfile grammar is an extension of the Dockerfile grammar.

The `COMPONENT` directive tells noop what the name of the component is.

The `ROUTE` directive tells noop how web requests should be routed to the component. In this case, it routes all HTTP `GET` requests for `/api/samples` to this component.

The `RESOURCE` directive tells noop that this component depends on a DynamoDB resource named `samples`. If the `samples` resource is not available or does not meet the requirements of this directive (in this case, the only requirement being that it be DynamoDB), then the component cannot be deployed.

The `ENV` directive works just like it does in a vanilla Dockerfile, except that the value can be a [JSON path](https://goessner.net/articles/JsonPath/) to a property from a part of the application. DynamoDB resources have a `tableName` property that is the name of the DynamoDB table of the resource, so `$.resources.samples.tableName` means "the `tableName` property of the `samples` resource.

The `FROM` directive is a vanilla Dockerfile `FROM`. However, the image being used is a helper image managed by Rearc to allow users to quickly write function components by just exporting a handler function.

The `FUNCTION` directive tells noop that this component is a function component. The arguments to the `FUNCTION` directive tell noop how to run the function inside the context of the container. In this case, the first argument is the path to the nodejs file that contains the function code, and the second argument is the name of the property exported by the file that has the function code.

All the other directives are vanilla Dockerfile directives.

You might want to take a moment to examine the contents of all of these directories.

## Testing locally

To test the sample application locally, you'll first need to install the noop CLI. You can do so in the terminal you opened earlier, using the following (presuming you already have `node`, `npm`, and docker installed):

```bash
npm install -g @rearc/noop-cli
```

This will install the noop CLI globally, so it will be available from anywhere on your system. Let's try running the application locally. Presuming you're still in the `noop-quickstart` directory, use:

```bash
noop run
```

The noop CLI will then read through the contents of the application repository. It will discover and read all of the noopfiles in the subdirectories, and run containers locally for each component using docker to emulate the behavior in the noop environment so that you can test stuff. Since some of the components have a resource requirement for a DynamoDB named `samples`, the CLI will also run a separate container with a local work-alike version of DynamoDB for testing.

Now that the application is running locally, open up a web browser and point it at `https://localnoop.app:1234`. Since the `ui` component is routed to by HTTP `GET`s to `*` (as you can see from the `ROUTE` directive in its noopfile), this will return the result of calling the `ui` component.

## Deploying into noop




TODO building
TODO decomposition

# -----

Developers write code and provide noop with the application and environment config. Noop takes care of everything from there. A noop application is usually comprised of multiple components (services, functions, tasks etc.) and resources. Noop understands the application, its configuration, dependencies and has full context for every application transaction as it flows through the noop platform. This contextual awareness allows noop to provide deep insights and capabilities to the developer, making living with the app much simple yet powerful.

There is much more to noop. We have made noop in such a way that developers can easily express the application build and run parameters while removing all the other infrastructure and cloud heavy lifting. For the purposes of alpha, we want you to experience the platform as a developer so that we can learn from your experience. We are looking to know what you like and not like about noop.

# Step 1: Clone the sample app
We are providing a sample app for you to get started with noop. The noop sample application is comprised of multiple components (services and functions). Services are long-running processes while functions provide developers to simply express their application logic through code and allow the underlying container platform to manage concurrency.

### Clone the sample app:
```
git clone git@github.com:rearc/noop-sample.git
cd noop-sample
```
Browse the sample app repo and inspect the Noopfile.

Learn more about Noopfiles [here](https://github.com/rearc/noop-docs/Noopfile.md).

# Step 2: Install the Noop CLI and run Noop locally
Noop CLI is an interactive command line interface for local development.

### Requirements for Noop CLI
- node
- git
- docker

### Package Install:
`npm install -g @rearc/noop-cli`
### Local Install:
```
git clone git@github.com:rearc/noop-cli.git
cd noop-cli
npm install
npm link
```
### Noop Run:
From within the git repo of the sample application, execute the following command to build and run your noop application locally.
`noop run`

In a different terminal window, use noop cli to analyze your current project directory to display summary information of your noop application.
`noop inspect`

# Step 3: Launch noop console

1. Launch Noop Console by visiting https://alpha.noop.app
Noop currently only supports federated login with Github. Click on `Login with Github`

![github-login](/images/console-github-login.png)

2. If you are not already logged in to github in your browser, you will have to log onto github by entering your github username and password.

![github-login2](/images/console-github-login2.png)

3. Once logged in, you should see the Noop console home. On the right hand corner, you should see `Organizations` you have access to. One of the organizations on the list should be your personal github org. Click on your personal org to manage your applications.

![console-home](/images/console-home.png)

## Step 5: Create a new repo, application, environment and an endpoint

1. The first step to launching your noop application is to add the application repo to your organization.

![add-repo](/images/console-add-repo.png)

2. Create a new application by clicking on `New App` within the Applications view

![create-application](/images/console-create-application.png)

3. Create a new environment within the application

![create-environment](/images/console-create-environment.png)

4. Create a new endpoint within an environment

![create-endpoint](/images/console-create-endpoint.png)

## Step 6: Build and deploy your application

1. Once an application environment is available, you can create new builds by supplying the branch name or the commit sha

![start-build](/images/console-start-build.png)

Currently, the build view does not auto-update when the build is complete. Go ahead and refresh the page after a minute to see if the build is complete.

2. Once the build is complete, click on `Stage Build` and subsequently `Deploy Changes` on the far right.

![stage-build-deploy](/images/console-stage-build-and-deploy.png)

3. Again, the Deploy view will not automatically update (we are working on it). Refresh the page and you will be able to click on a link in the deploy view to see the deployment change status

![deploy-status](/images/console-deploy-status.png)

## Step 7:View component logs and access the endpoint

If your application was successfully deployed, you will be able to click on `Components` on the left column and see a list of all your application components discovered by Noop.

We are still working on the metric and other views. As of now, we have logs working within the console to help troubleshoot any application issues. On the Logging component of the sample app, click on the first icon to see logs for the `logging` component of the environment you created for the sample app. Within the log view, you will have a couple options to filter and retrieve logs.

![components](/images/console-components.png)

Finally, go to the `Endpoints` view and click on the endpoint to access the sample app page. Some example routes for the sample app are:

- https://your-endpoint.alpha.noop.app/ (from ui service)
- https://your-endpoint.alpha.noop.app/api (from api function)
- https://your-endpoint.alpha.noop.app/bar (from anotherui service)
- https://your-endpoint.alpha.noop.app/go/bar (from gohello service)

## Step 8: Try running your awesome app on Noop and reach out if you have any questions!
